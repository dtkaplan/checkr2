% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sequences.R
\name{line_where}
\alias{line_where}
\alias{lines_after}
\title{Identify an individual line in a sequence of commands}
\usage{
line_where(tidy_code, ..., fail = "", pass = "", type = NULL)
}
\arguments{
\item{tidy_code}{expressions as made by for_checkr()}

\item{...}{tests specifying the kind of line we want}

\item{fail}{if a non-empty string, trigger a failure if no matching
line is found, with the string as the message.}

\item{pass}{if a non-empty string, call the result a pass rather than an OK}

\item{type}{a test to check whether V is a certain type, e.g. \code{is.numeric}.}
}
\value{
A checkr test result. By default, if the line is found, the result
is an "OK", setting the stage for further testing. The \code{pass} argument, if given,
turns this into a definitive pass. If no matching line is found, the result is a fail.
}
\description{
The tests are written in terms of pronouns
\itemize{
\item F the function at the highest level (but with assignment removed)
\item Z the name being bound to the line's value by assignment. ("" if no assignment.)
\item V the value produced by the line.
\item EX the expression itself (but with assignment removed)
}
}
\details{
\code{fail}, \code{pass} and \code{type} are optional. The \code{fail} argument merely sets the
message if no matching line is found. \code{type} can be used to ensure that the value
V is an appropriate kind for the tests specified in ... The \code{pass} argument
will mark the result as a definitive pass, rather than the default of OK if the
line is found.
}
\examples{
tidy_code <- for_checkr(quote({x <- 2; y <- x^3; z <- y + x}))
line_where(tidy_code, F \%same_as\% quote(`^`))

}
