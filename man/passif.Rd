% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/passif.R
\name{passif}
\alias{passif}
\alias{failif}
\alias{noteif}
\alias{failif}
\alias{noteif}
\title{Collate a test expression with a message and a action.}
\usage{
passif(test, message = default_message)

failif(test, message = default_message)

noteif(test, message = default_message)
}
\arguments{
\item{test}{an expression written in terms of values found
in the pattern-matching bindings}

\item{message}{a character string containing the message to return.}
}
\description{
These functions are simply a way to associate a message with a test.
The test itself will be evaluated in \code{line_} functions, \code{arg_} functions, \code{check()}, etc.
}
\details{
The \code{message} can include components calculated from the bindings.
Enclose these in moustaches, e.g. "The \code{{{F}}} function is not appropriate for adding."
Within a test, the operators \code{==} and \code{!=} in a test have been augmented to deal
with language objects such as names. They are translated to be equivalent to "\%same_as\%".
You can refer to the expression being tested with \code{{{expression_string}}} and to the \code{test} itself as \code{{{test_string}}}.
}
\examples{
code <- for_checkr(quote({x <- 2; y <- x^2; z <- x + y}))
my_line <- line_where(code, F == `+`)
# note: a double negative ... fail and y != 4
check_binding(my_line, `+`(..(x), ..(y)), failif(y != 4, "use 4 for the second argument to +"))

}
