% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bind.R
\name{chk}
\alias{chk}
\alias{bind}
\title{Looks for a match to patterns.}
\usage{
chk(tidy_code, ..., fail = "")
}
\arguments{
\item{...}{tests to apply to expressions in \code{ex}. These are typically made
with \code{passif()}, \code{failif()}, \code{noteif()}, \code{bind()}, and so on.}

\item{fail}{a character string message. By default, the function
will return an "ok" checkr_result if the patterns don't match. If
fail is not empty, then a "fail" checkr_result will be returned with
the value of fail as the message.}

\item{ex}{an expression or {}-bracketed set of expressions. This may
be produced by \code{quote()}, or \code{parse(text = ...)} or some similar language
mechanism.}

\item{keys}{an R statement used for pattern matching and binding, based
on the redpen package. This can also be a {}-bracketed set of patterns.}
}
\value{
A checkr_test object with an action ("pass", "fail", or "ok") and a
message to be displayed to the user.

a test-result list containing a message string and a directive
about whether the expressions in \code{ex} passed the test.
}
\description{
Looks for a match of all the patterns to one of the expressions. If the match is found, the
tests (see \code{...}) are evaluated in order. A pass or a fail causes an immediate
termination of the testing and returns that result. If no pass or fail occurs, a neutral result
is created so that evaluation can proceed to subsequent statements.
}
\details{
If the patterns match some statement in the expressions, then the tests are evaluated
using the bindings established in the pattern match.

The pattern \code{pat} is applied to each of the expressions in \code{ex}.
The tests are only considered for the first expression in \code{ex} that matches
the pattern.  \code{passif()} and \code{failif()} tests, when satisfied, lead to immediate
return: no other tests are performed. \code{noteif()} just adds a note, without
terminating the testing.
}
\examples{
ex <- for_checkr(quote(2+2))
wrong1 <- for_checkr(quote(2 - 2))
wrong2 <- for_checkr(quote(2*2))
bind(ex, 2 + 2, passif(TRUE, "carbon copy"))
bind(ex, 3 + 3)
bind(ex, 3 + 3, passif(TRUE, "not a match"))
bind(ex, 3 + 3, passif(TRUE, "not a match"), fail = "not a match")
bind(ex, 2 + ..(y), must(y != 2, "{{expression_string}} wasn't right. Second argument should not be {{y}}"))
bind(ex, `+`(.(a), .(b)), passif(TRUE))
bind(ex, `+`(.(a), .(b)),
  passif(a==b, message = "Yes, they are equal!"))
bind(ex, `+`(.(a), .(b)),
  passif(a==b,
     message = "Yes, they are equal! In this case, they are both {{a}}."))
bind(wrong1, {.(expr); .(f)(.(a), .(b))},
  passif(f == `+`, "Right! Addition means {{f}}."),
  failif(f != `+`, "In {{expr}}, you used {{f}} instead of +"))
bind(wrong2, {.(fn)(.(a), .(b)); ..(val)},
  noteif(val == 4, "Right overall answer: {{val}}."),
  failif(fn != `+`, "You need to use the `+` function, not {{fn}}."),
  noteif(val != 4, "The result should be 4, not {{val}}."),
  passif(fn == `+` && val == 4 && a == b))
code2 <- for_checkr(quote({data(mtcars); plot(mpg ~ hp, data = mtcars)}))
bind(code2,
  # note, single . with .(fn)
  {..(val); .(fn)(.(formula), data = mtcars);},
  passif(fn == quote(plot), "You made the plot!"))
}
